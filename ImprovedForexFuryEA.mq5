//+------------------------------------------------------------------+
//|                                      OncePerDayEA.mq5           |
//|           EA: 1-trade-per-day, ATR filter, trailing & breakeven  |
//+------------------------------------------------------------------+
#property copyright "Generated by ChatGPT"
#property version   "1.00"
#property strict

#include <Trade\Trade.mqh>

input double   Lots             = 0.1;     // Lot size per trade
input int      StopLossPoints   = 50;      // Stop Loss (points)
input int      TakeProfitPoints = 50;      // Take Profit (points)
input bool     UseTrailingStop  = false;   // Enable trailing stop
input int      TrailingStep     = 20;      // Trailing stop step (points)
input int      TrailingStart    = 30;      // Profit (points) to start trailing
input bool     UseBreakEven     = false;   // Enable break-even at profit
input int      BreakEvenPoints  = 30;      // Profit (points) to move SL to breakeven
input bool     UseATRFilter     = false;   // Enable ATR volatility filter
input int      ATRPeriod        = 14;      // ATR period
input double   ATRThreshold     = 100.0;   // ATR threshold (points)
input bool     AllowSell        = false;   // Allow SELL trades (default is BUY only)
input int      MagicNumber      = 123456;  // Magic number for this EA
input int      Slippage         = 10;      // Slippage (points)
input int      StartHour        = 22;      // Earliest trading hour (server time)
input int      EndHour          = 23;      // Latest trading hour

CTrade trade;               // Trading object
int    lastTradeDate = 0;   // Tracks last trade date to enforce one trade per day

//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
{
   // Configure trade settings
   trade.SetExpertMagicNumber(MagicNumber);
   trade.SetDeviationInPoints(Slippage);
   return INIT_SUCCEEDED;
}

//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick()
{
   // Get current server time components
   datetime now = TimeCurrent();
   MqlDateTime dt;
   TimeToStruct(now, dt);  // dt.day_of_week: 0=Sunday,...5=Friday,6=Saturday

   // *** Weekend handling: if it's Friday, close any open positions ***

   if(dt.day_of_week == FRIDAY)
   {
      // Close all positions belonging to this EA (match magic and symbol)
      for(int i = PositionsTotal() - 1; i >= 0; i--)
      {
         ulong ticket = PositionGetTicket(i);
         if(ticket == 0) continue;
         // Filter positions by magic and symbol
         if((int)PositionGetInteger(POSITION_MAGIC) == MagicNumber 
            && PositionGetString(POSITION_SYMBOL) == _Symbol)
         {
            trade.PositionClose(ticket);
         }
      }
      // Do not open new trades on Friday
      return;
   }

   // *** Manage Trailing Stop and Break-Even for existing positions ***
   for(int i = PositionsTotal() - 1; i >= 0; i--)
   {
      ulong ticket = PositionGetTicket(i);
      if(ticket == 0) continue;
      // Only manage our EA's positions on this symbol
      if((int)PositionGetInteger(POSITION_MAGIC) != MagicNumber) continue;
      if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;

      double entryPrice = PositionGetDouble(POSITION_PRICE_OPEN);
      double stopPrice  = PositionGetDouble(POSITION_SL);
      double tpPrice    = PositionGetDouble(POSITION_TP);
      ENUM_POSITION_TYPE type = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);

      if(type == POSITION_TYPE_BUY)
      {
         double bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);
         double profitPoints = (bid - entryPrice) / _Point;

         // Break-even logic: set SL to entry when profit reaches threshold
         if(UseBreakEven && profitPoints >= BreakEvenPoints && stopPrice < entryPrice)
         {
            trade.PositionModify(ticket, entryPrice, tpPrice);
         }
         // Trailing stop logic
         else if(UseTrailingStop && profitPoints >= TrailingStart)
         {
            double newSL = bid - TrailingStep * _Point;
            if(newSL > stopPrice) // only move SL if higher than current SL
               trade.PositionModify(ticket, newSL, tpPrice);
         }
      }
      else if(type == POSITION_TYPE_SELL)
      {
         double ask = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
         double profitPoints = (entryPrice - ask) / _Point;

         // Break-even for sell positions
         if(UseBreakEven && profitPoints >= BreakEvenPoints && stopPrice > entryPrice)
         {
            trade.PositionModify(ticket, entryPrice, tpPrice);
         }
         // Trailing stop for sell
         else if(UseTrailingStop && profitPoints >= TrailingStart)
         {
            double newSL = ask + TrailingStep * _Point;
            if(newSL < stopPrice || stopPrice == 0.0) // move SL down if lower (or if no SL set)
               trade.PositionModify(ticket, newSL, tpPrice);
         }
      }
   }

   // *** Trading logic: Only proceed if within allowed hours and haven't traded today ***
   int today = dt.year*10000 + dt.mon*100 + dt.day;
   if(dt.hour < StartHour || dt.hour > EndHour || lastTradeDate == today)
      return;

   // *** ATR volatility filter (skip trade if ATR > threshold) ***
   if(UseATRFilter)
   {
      int atrHandle = iATR(_Symbol, _Period, ATRPeriod);
      if(atrHandle != INVALID_HANDLE)
      {
         double atrBuffer[];
         if(CopyBuffer(atrHandle, 0, 0, 1, atrBuffer) > 0)
         {
            double atrValue = atrBuffer[0];
            // If ATR is above threshold (in points), skip trading
            if(atrValue > ATRThreshold * _Point)
            {
               IndicatorRelease(atrHandle);
               return;
            }
         }
         IndicatorRelease(atrHandle);
      }
   }

   // *** Entry conditions ***
   double AskPrice = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
   double BidPrice = SymbolInfoDouble(_Symbol, SYMBOL_BID);
   double prevClose = iClose(_Symbol, PERIOD_D1, 1);
   double prevOpen  = iOpen(_Symbol,  PERIOD_D1, 1);

   bool bullish = (prevClose > prevOpen);
   bool bearish = (prevClose < prevOpen);

   // By default, only BUY. If bearish and selling is allowed, SELL instead.
   if(bullish)
   {
      // Open BUY: volume, symbol, price, SL, TP, comment
      if(trade.Buy(Lots, _Symbol, AskPrice,
                   AskPrice - StopLossPoints*_Point,
                   AskPrice + TakeProfitPoints*_Point,
                   "")) // empty comment
      {
         lastTradeDate = today;
      }
   }
   else if(bearish && AllowSell)
   {
      // Open SELL
      if(trade.Sell(Lots, _Symbol, BidPrice,
                    BidPrice + StopLossPoints*_Point,
                    BidPrice - TakeProfitPoints*_Point,
                    "")) // empty comment
      {
         lastTradeDate = today;
      }
   }
}
//+------------------------------------------------------------------+
